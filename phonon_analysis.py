import os
import numpy as np
import matplotlib.pyplot as plt
from sisl.io import get_sile
from .geometry import *
from .tools import *
import xarray
from typing import List, Tuple, Union


def read_phonon_bands(
    name, path="./phonon", as_dataarray=True, squeeze=True
) -> xarray.DataArray:
    """
    Read phonon band structure from name.bands file, which is generated by
    Siesta/Util/Vibra
    """

    bands_path = os.path.join(path, f"{name}.bands")
    # read data using methods in sisl
    bandsile = get_sile(bands_path)
    bands = bandsile.read_data(as_dataarray=as_dataarray)
    # remove redundant dimension of data
    if squeeze:
        bands = bands.squeeze()
    if bands.ticklabels[0] == "Gamma":
        bands.ticklabels[0] = "$\Gamma$"
    if bands.ticklabels[1] == "X":
        bands.ticklabels[1] = "$X$"
    bands.k.data[:] *= 1.8897259886
    return bands


def plot_phonon_bands(
    name,
    path="./phonon",
    Erange=None,
    figsize=(8, 6),
    ticks_font=12,
    label_font=12,
    title=False,
    title_font=14,
    border_line_width=2,
    save=False,
    save_format="png",
    dpi=300,
    ax2=True,
    **kwargs,
):
    """
    Plot phonon band structure from name.bands file
    Arguments:
        name: name of the geometry, which is also the name of files
        path: path to read and write files
        Erange: energy range to plot the dispersion
        figsize: figure size
        ticks_font, label_font, title_font, border_line_width: arguments for figure
        save, save_format, dpi: arguments for saving figure
        ax2: plot right axis in frequency (cm^-1) unit or not
    """

    bands = read_phonon_bands(name=name, path=path,
                              as_dataarray=True, squeeze=True)
    # k points
    ks = bands.k.data

    fig = plt.figure(figsize=figsize)
    # ax1 is in energy (meV) scale
    ax1 = fig.add_subplot(111)
    # set y axis limit if Energy range is given
    if Erange:
        emin, emax = Erange
        ax1.set_ylim(emin, emax)
    else:
        emin, emax = -1e2, 1e6
    ax1.set_ylabel("Energy (meV)", fontsize=label_font)
    ax1.set_xticks(bands.ticks)
    ax1.set_xticklabels(bands.ticklabels)
    ax1.set_xlim(bands.ticks)
    ax1.tick_params(axis='x', labelsize=ticks_font)
    ax1.tick_params(axis='y', labelsize=ticks_font)

    # optional ax2 is in frequency (cm^-1) scale
    if ax2:
        ax2 = ax1.twinx()
        ax2.set_ylabel("Frequency ($cm^{-1}$)", fontsize=label_font)
        ax2.set_ylim(np.array(ax1.get_ylim()) * 8.066)

    # plot the data
    for i in range(bands.shape[1]):
        band = bands[:, i] / 8.066
        # select the bands that are in the given energy window
        if np.any(np.logical_and(band > emin, band < emax)):
            ax1.plot(ks, band, color="k", **kwargs)
    if title:
        fig_title = "{}_PhononDispersion".format(name)
        ax1.set_title(fig_title + "\n", fontsize=title_font)

    # set border width
    for border in ["left", "bottom", "top", "right"]:
        ax1.spines[border].set_linewidth(border_line_width)

    # save the figure
    if save:
        enrg_str = "{}to{}meV".format(emin, emax) if Erange else "full_range"
        fig_name = name + "_PhononDispersion_" + enrg_str
        fig_path = os.path.join(path, fig_name + "." + save_format)
        fig.savefig(fig_path, dpi=dpi)


def write_GammaPhonon_xsf(
    name, geom, first_band: int, last_band: int, path="./phonon", num_of_cells=1
):
    """
    Write xsf files to visualize phonon modes at Gamma point
    (It is more complicated to visualize the phonon mode at general k point, as
    it's has to be represented by a video to fully interprete the info in the data)
    Argument:
        first_band: first band to write
        last_band: last band to write
        path: path to read and write files
        num_of_cells: number of unit cells to write
    """
    vec_path = os.path.join(path, f"{name}.vectors")
    with open(vec_path, "r") as vf:
        # skip the first two lines
        for l in range(2):
            vf.readline()
        # skip unwanted bands
        for b in range(first_band - 1):
            for l in range(2 + 2 * (geom.na + 1)):
                vf.readline()
        # read selected bands
        for b in np.arange(first_band, last_band + 1, 1):
            band = int(vf.readline()[-6:].strip())  # label of band
            freq = float(vf.readline()[14:].strip())  # cm-1
            enrg = freq / 8.066
            vf.readline()  # real part
            vector = np.empty((geom.na, 3))
            for i in range(geom.na):
                v = vf.readline().strip().split()
                vec = np.array([float(a) for a in v])
                vector[i, :] = vec
            for i in range(geom.na + 1):
                vf.readline()

            with open(
                os.path.join(
                    path, "{}_GammaMode_{}_{:.2f}meV.xsf".format(
                        name, band, enrg)
                ),
                "w",
            ) as xsf:
                xsf.write("# ---- XSF block for ---- \n")
                xsf.write(f"# mode = {band} (Gamma)\n")
                xsf.write(f"# frequency = {freq} cm-1\n")
                xsf.write(f"# energy = {enrg} meV\n")
                xsf.write("CRYSTAL\n")
                # write primitive cell
                xsf.write("PRIMVEC\n")
                for i in range(3):
                    xsf.write("  {:.8f}  {:.8f}  {:.8f}\n".format(
                        *geom.cell[i, :]))
                xsf.write("CONVVEC\n")
                for i in range(3):
                    xsf.write("  {:.8f}  {:.8f}  {:.8f}\n".format(
                        *geom.cell[i, :]))
                xsf.write("PRIMCOORD\n")
                xsf.write("  {}  {}\n".format(geom.na, num_of_cells))
                # write coordinates and displacement vectors for each atoms
                for i, a, _ in geom.iter_species():
                    xsf.write(
                        "  {}  {:.8f}  {:.8f}  {:.8f}  {:.8f}  {:.8f}  {:.8f}\n".format(
                            a.Z, *geom.xyz[i, :], *vector[i, :]
                        )
                    )


def read_phonon_vectors(
    geom, name, first_band: int, last_band: int, path="./phonon"
) -> np.ndarray:
    """
    Read the phonon eigenvectors from name.vectors file. By default read the
    vectors for all k points and selected bands.
    Arguments:
        first_band: first band to read
        last_band: last band to read
    """
    # empty list to store all the vectors
    vectors = []
    vec_path = os.path.join(path, f"{name}.vectors")
    # empty list to store all k points
    kpts = []
    # empty list to store all energy values (in meV)
    enrgs = []
    # indicator of number of empty lines. If more than 2 empty lines then it marks
    # the end of file
    emp = 0
    with open(vec_path, "r") as vf:
        # keep reading the file until the end
        while emp < 3:
            line = vf.readline()
            if len(line) == 0:
                emp += 1
            # If find 'k' in the line, then it is the start of a data block that
            # stores all the data for that k point
            if "k" in line:
                # initialize empty list to store the data for a k point
                vectors_k = []
                enrg_k = []
                emp = 0
                # read the k point
                kline = line.strip().split()[-3:]
                kpts.append([float(i) for i in kline])
                # skip the unwanted vectors
                for b in range(first_band - 1):
                    for l in range(2 + 2 * (geom.na + 1)):
                        vf.readline()
                # now read the bands that we want
                for b in np.arange(first_band, last_band + 1):
                    band = int(vf.readline()[-6:].strip())  # label of band
                    freq = float(vf.readline().strip().split()[-1])  # cm-1
                    enrg = freq / 8.066
                    enrg_k.append(enrg)
                    # initialize empty array to store vectors for a band
                    vector_b = np.empty((geom.na, 3), dtype=complex)
                    # start to the read part of the vector
                    vf.readline()  # Eigenmode (real part)
                    for i in range(geom.na):
                        v = vf.readline().strip().split()
                        real = np.array([float(a) for a in v], dtype=complex)
                        vector_b[i] = real
                    # start to read the imaginary part of the vector
                    vf.readline()  # Eigenmode (imaginary part)
                    for i in range(geom.na):
                        v = vf.readline().strip().split()
                        imag = 1j * np.array([float(a) for a in v])
                        vector_b[i, :] += imag
                    vectors_k.append(vector_b)
                enrgs.append(enrg_k)
                vectors.append(vectors_k)
    kpts = np.array(kpts)
    kpts[:] *= 1.8897259886 # convert to Ang^-1
    enrgs = np.array(enrgs)
    vectors = np.array(vectors)
    return kpts, enrgs, vectors


def fat_phonon_bands(
    geom,
    name,
    first_band: int,
    last_band: int,
    path="./phonon",
    Erange=None,
    figsize=(8, 6),
    project_list: Union[List, Tuple, np.ndarray] = None,
    label: str = None,
    line_opacity=0.0,
    marker_size=50,
    cmap="inferno_r",
    ticks_font=12,
    label_font=12,
    title_font=14,
    border_line_width=2,
    save=False,
    save_format="png",
    dpi=600,
    ax2=True,
    **kwargs,
):
    """
    Plot the fat phonon dispersion relation projecting on selected atoms
    Arguments:
        first_band: first band to project
        last_band: last band to project
        path: path to load and write files
        Erange: energy range to plot the dispersion, in meV unit
        figsize: figure size
        project_list: list of atoms to be projected on
        label: label to be shown in the title of the figure
        line_opacity: opacity of the original dispersion lines
        marker_size: size of the markers of fat bands
        cmap: color map
        ticks_font, label_font, title_font, border_line_width: arguments for figure
        save: save figures or not
        save_format: format of the figuer to be saved, usually png, or pdf
        dpi: dots per inch
        ax2: plot vertical axis at right or no, in frequency units, while the default
            left axis is in energy meV unit
    """
    # read phonon band data from name.bands file in phonon calculation directory
    bands = read_phonon_bands(name=name, path=path,
                              as_dataarray=True, squeeze=True)
    # read all the phonon vectors
    ph_kpts, ph_enrgs, ph_vectors = read_phonon_vectors(
        geom=geom, name=name, path=path, first_band=first_band, last_band=last_band
    )
    # Convert k points to one dimension, as we are mainly dealing with one
    # dimensional system
    kpts = ph_kpts[:, 0]
    # modulus of phonon vectors of all atoms
    ph_mod_tot = np.linalg.norm(ph_vectors[:, :, :, :], axis=-1).sum(-1)
    # modulus of phonon vectors of selected to-be-projected atoms
    ph_mod_proj = np.linalg.norm(
        ph_vectors[:, :, project_list, :], axis=-1).sum(-1)
    ph_wt_proj = ph_mod_proj / ph_mod_tot

    fig = plt.figure(figsize=figsize)
    ax1 = fig.add_subplot(111)
    if Erange:
        emin, emax = Erange
        ax1.set_ylim(emin, emax)
    else:
        emin, emax = -1e2, 1e6
    ax1.set_ylabel("Energy (meV)", fontsize=label_font)
    ax1.set_xticks(bands.ticks)
    ax1.set_xticklabels(bands.ticklabels, fontsize=ticks_font)
    ax1.set_xlim(bands.ticks)
    if ax2:
        ax2 = ax1.twinx()
        ax2.set_ylabel("Frequency ($cm^{-1}$)", fontsize=label_font)
        ax2.set_ylim(np.array(ax1.get_ylim()) * 8.066)

    # plot the data
    for i in range(last_band - first_band + 1):
        band = ph_enrgs[:, i]
        if np.any(np.logical_and(band > emin, band < emax)):
            # plot original dispersion
            ax1.plot(kpts, band, color="k", alpha=line_opacity, **kwargs)
            # plot fat dispersion
            fat_disp = ax1.scatter(
                kpts, band, s=marker_size, c=ph_wt_proj[:, i], cmap=cmap
            )
    plt.colorbar(fat_disp, ax=ax1, shrink=0.8, location="right", pad=0.15)

    fat_disp.set_clim(0.0, 1.0)
    fig_title = "Fat Phonon Dispersion for {}".format(label)
    ax1.set_title(fig_title + "\n", fontsize=title_font)

    # set border width
    for border in ["left", "bottom", "top", "right"]:
        ax1.spines[border].set_linewidth(border_line_width)

    # save the figure
    if save:
        enrg_str = "{}to{}meV".format(emin, emax) if Erange else "full_range"
        fig_name = name + "_FatPhononDispersion-{}_".format(label)
        fig_name += enrg_str
        fig_path = os.path.join(path, fig_name + "." + save_format)
        fig.savefig(fig_path, dpi=dpi)
