import os
import numpy as np
import matplotlib.pyplot as plt
from sisl.io import get_sile
from .geometry import *
from .tools import *
import xarray
from typing import List, Tuple, Union


def read_phonon_bands(
    name, path="./phonon", as_dataarray=True, squeeze=True
) -> xarray.DataArray:
    """
    Read phonon band structure from name.bands file, which is generated by
    Siesta/Util/Vibra
    """

    bands_path = os.path.join(path, f"{name}.bands")
    # read data using methods in sisl
    bandsile = get_sile(bands_path)
    bands = bandsile.read_data(as_dataarray=as_dataarray)
    # remove redundant dimension of data
    if squeeze:
        bands = bands.squeeze()
    if bands.ticklabels[0] == "Gamma":
        bands.ticklabels[0] = "$\Gamma$"
    if bands.ticklabels[1] == "X":
        bands.ticklabels[1] = "$X$"
    bands.k.data[:] *= 1.8897259886
    bands.ticks[:] = np.array(bands.ticks)*1.8897259886
    return bands


def read_phonon_vectors(
    geom, name, first_band: int, last_band: int, path="./phonon"
) -> np.ndarray:
    """
    Read the phonon eigenvectors from name.vectors file. By default read the
    vectors for all k points and selected bands.
    Arguments:
        first_band: first band to read
        last_band: last band to read
    """
    # empty list to store all the vectors
    vectors = []
    vec_path = os.path.join(path, f"{name}.vectors")
    # empty list to store all k points
    kpts = []
    # empty list to store all energy values (in meV)
    enrgs = []
    # indicator of number of empty lines. If more than 2 empty lines then it marks
    # the end of file
    emp = 0
    with open(vec_path, "r") as vf:
        # keep reading the file until the end
        while emp < 3:
            line = vf.readline()
            if len(line) == 0:
                emp += 1
            # If find 'k' in the line, then it is the start of a data block that
            # stores all the data for that k point
            if "k" in line:
                # initialize empty list to store the data for a k point
                vectors_k = []
                enrg_k = []
                emp = 0
                # read the k point
                kline = line.strip().split()[-3:]
                kpts.append([float(i) for i in kline])
                # skip the unwanted vectors
                for b in range(first_band - 1):
                    for l in range(2 + 2 * (geom.na + 1)):
                        vf.readline()
                # now read the bands that we want
                for b in np.arange(first_band, last_band + 1):
                    band = int(vf.readline()[-6:].strip())  # label of band
                    freq = float(vf.readline().strip().split()[-1])  # cm-1
                    enrg = freq / 8.066
                    enrg_k.append(enrg)
                    # initialize empty array to store vectors for a band
                    vector_b = np.empty((geom.na, 3), dtype=complex)
                    # start to the read part of the vector
                    vf.readline()  # Eigenmode (real part)
                    for i in range(geom.na):
                        v = vf.readline().strip().split()
                        real = np.array([float(a) for a in v], dtype=complex)
                        vector_b[i] = real
                    # start to read the imaginary part of the vector
                    vf.readline()  # Eigenmode (imaginary part)
                    for i in range(geom.na):
                        v = vf.readline().strip().split()
                        imag = 1j * np.array([float(a) for a in v])
                        vector_b[i, :] += imag
                    vectors_k.append(vector_b)
                enrgs.append(enrg_k)
                vectors.append(vectors_k)
    kpts = np.array(kpts)
    kpts[:] *= 1.8897259886  # convert to Ang^-1
    enrgs = np.array(enrgs)
    vectors = np.array(vectors)
    return kpts, enrgs, vectors


def plot_phonon_bands(
    name,
    path="./phonon",
    Erange=None,
    figsize=(8, 6),
    ticks_font=12,
    label_font=12,
    title=False,
    title_font=14,
    border_line_width=2,
    save=False,
    save_format="png",
    dpi=300,
    ax2=True,
    **kwargs,
):
    """
    Plot phonon band structure from name.bands file
    Arguments:
        name: name of the geometry, which is also the name of files
        path: path to read and write files
        Erange: energy range to plot the dispersion
        figsize: figure size
        ticks_font, label_font, title_font, border_line_width: arguments for figure
        save, save_format, dpi: arguments for saving figure
        ax2: plot right axis in frequency (cm^-1) unit or not
    """

    bands = read_phonon_bands(name=name, path=path,
                              as_dataarray=True, squeeze=True)
    # k points
    ks = bands.k.data

    fig = plt.figure(figsize=figsize)
    # ax1 is in energy (meV) scale
    ax1 = fig.add_subplot(111)
    # set y axis limit if Energy range is given
    if Erange:
        emin, emax = Erange
        ax1.set_ylim(emin, emax)
    else:
        emin, emax = -1e2, 1e6
    ax1.set_ylabel("Energy (meV)", fontsize=label_font)
    ax1.set_xticks(bands.ticks)
    ax1.set_xticklabels(bands.ticklabels)
    ax1.set_xlim(bands.ticks)
    ax1.tick_params(axis='x', labelsize=ticks_font)
    ax1.tick_params(axis='y', labelsize=ticks_font)

    # optional ax2 is in frequency (cm^-1) scale
    if ax2:
        ax2 = ax1.twinx()
        ax2.set_ylabel("Frequency ($cm^{-1}$)", fontsize=label_font)
        ax2.set_ylim(np.array(ax1.get_ylim()) * 8.066)

    # plot the data
    for i in range(bands.shape[1]):
        band = bands[:, i] / 8.066
        # select the bands that are in the given energy window
        if np.any(np.logical_and(band > emin, band < emax)):
            ax1.plot(ks, band, color="k", **kwargs)
    if title:
        fig_title = "{}_PhononDispersion".format(name)
        ax1.set_title(fig_title + "\n", fontsize=title_font)

    # set border width
    for border in ["left", "bottom", "top", "right"]:
        ax1.spines[border].set_linewidth(border_line_width)

    # save the figure
    if save:
        enrg_str = "{}to{}meV".format(emin, emax) if Erange else "full_range"
        fig_name = name + "_PhononDispersion_" + enrg_str
        fig_path = os.path.join(path, fig_name + "." + save_format)
        fig.savefig(fig_path, dpi=dpi)


def write_phonon_xsf(
    geo, name, first_band: int, last_band: int, path="./phonon", num_of_cells=1,
    q=[0, 0, 0]
):
    """
    Write xsf files to visualize phonon modes at Gamma point
    (It is more complicated to visualize the phonon mode at general k point, as
    it's has to be represented by a video to fully interprete the info in the data)
    Argument:
        first_band: first band to write
        last_band: last band to write
        path: path to read and write files
        num_of_cells: number of unit cells to write
    """
    kpts, enrgs, vectors = read_phonon_vectors(
        geom=geo, name=name, path=path, first_band=first_band, last_band=last_band
    )
    newGeo = geo.tile(num_of_cells, 0)
    coord = newGeo.xyz
    # lattice vector
    cell = geo.cell
    # reciprocal lattice vector, Ang^-1
    rcell = geo.rcell
    # reduced lattice coordinates. The full coordiante is R + r, R is vector of
    # the unit cell, r is the vector within the unit cell
    R = np.floor(coord/cell.diagonal())*cell.diagonal()
    # calculate the real wavevector from reduced wavevector
    qReal = np.multiply(rcell.diagonal(), np.array(q))
    # find the closest k (or called q) point to specified q point from the kpts list
    i_q = 0
    _q = kpts[i_q]  # the q that is closest to qReal
    for i, qtmp in enumerate(kpts):
        if np.linalg.norm(qReal-qtmp) < np.linalg.norm(qReal-_q):
            i_q = i
            _q = qtmp

    for i in range(last_band-first_band+1):
        ib = first_band+i-1
        energy = enrgs[i_q, i]
        phvec = vectors[i_q, i, :, :]
        # vector times e^(ikR)
        _vec = np.tile(phvec, (num_of_cells, 1))
        _phase = np.exp(1j*R*_q)
        newPhVec = np.multiply(_vec, _phase)
        xsf_file = "{}_{}_K{:.2f}_B{}_{:.2f}meV.xsf".format(
            name, num_of_cells, q[0], ib+1, energy)

        with open(os.path.join(path, xsf_file), "w") as xsf:
            xsf.write("# ---- XSF block for ---- \n")
            xsf.write("# q = {:.6f}\t{:.6f}\t{:.6f}\t\n".format(*_q))
            xsf.write(f"# mode = {ib+1}\n")
            xsf.write(f"# frequency = {energy*8.066} cm-1\n")
            xsf.write(f"# energy = {energy} meV\n")
            xsf.write("CRYSTAL\n")
            # write primitive cell
            xsf.write("PRIMVEC\n")
            for i in range(3):
                xsf.write("  {:.8f}  {:.8f}  {:.8f}\n".format(
                    *newGeo.cell[i, :]))
            xsf.write("CONVVEC\n")
            for i in range(3):
                xsf.write("  {:.8f}  {:.8f}  {:.8f}\n".format(
                    *newGeo.cell[i, :]))
            xsf.write("PRIMCOORD\n")
            xsf.write("  {}  {}\n".format(newGeo.na, num_of_cells))
            # write coordinates and displacement vectors for each atoms
            for i, a, _ in newGeo.iter_species():
                xsf.write(
                    "  {}  {:.8f}  {:.8f}  {:.8f}  {:.8f}  {:.8f}  {:.8f}\n".format(
                        a.Z, *newGeo.xyz[i, :], *np.real(newPhVec[i, :])
                    )
                )


def write_axsf_movie(geo, name, path,
                     first_band, last_band, steps=100,
                     num_of_cells=5, q=[0, 0, 0], amplitude=1.0):
    """
    Write AXSF file to visualize the phonon mode.
    Write files for multiple bands but for one specified wavevector (q)
    Args:
        geo: sisl Geometry
        path: path to read and write files
        file_name: output file name
        phvec: phonon vector
        iev: index of the eigenvector (phonon band index)
        energy: energy of this mode, by default in meV unit
        steps: number of animation steps
        num_of_cells: number of unit cells to plot
        q: reduced phonon wavevector ([0.5,0,0] means X)
    """
    kpts, enrgs, vectors = read_phonon_vectors(
        geo, name, first_band, last_band)

    newGeo = geo.tile(num_of_cells, 0)
    coord = newGeo.xyz
    # lattice vector
    cell = geo.cell
    # reciprocal lattice vector, Ang^-1
    rcell = geo.rcell
    # reduced lattice coordinates. The full coordiante is R + r, R is vector of
    # the unit cell, r is the vector within the unit cell
    R = np.floor(coord/cell.diagonal())*cell.diagonal()
    # calculate the real wavevector from reduced wavevector
    qReal = np.multiply(rcell.diagonal(), np.array(q))
    # find the closest k (or called q) point to specified q point from the kpts list
    i_q = 0
    _q = kpts[i_q]  # the q that is closest to qReal
    for i, qtmp in enumerate(kpts):
        if np.linalg.norm(qReal-qtmp) < np.linalg.norm(qReal-_q):
            i_q = i
            _q = qtmp

    for i in range(last_band-first_band+1):
        ib = first_band+i-1
        energy = enrgs[i_q, i]
        axsf_file = "{}_{}_K{:.2f}_B{}_{:.2f}meV.axsf".format(
            name, num_of_cells, q[0], ib+1, energy)
        phvec = vectors[i_q, i, :, :]
        # vector times e^(ikR)
        _vec = np.tile(phvec, (num_of_cells, 1))
        _phase = np.exp(1j*R*_q)
        newPhVec = np.multiply(_vec, _phase)
        with open(os.path.join(path, axsf_file), 'w') as axsf:
            axsf.write(f"# ---- AXSF block ----\n")
            axsf.write("# iev = {}\t energy = {} meV (freq = {} cm-1)\n".format(
                ib+1, energy, energy*8.066))
            axsf.write(f"ANIMSTEPS {steps}\n")
            for i in range(steps):
                axsf.write(f"ATOMS {i+1}\n")
                tmpPhVec = newPhVec*np.exp(1j*(2*np.pi*i/steps+np.pi/2))
                tmpPhVec = np.real(tmpPhVec)
                tmpCoord = coord + amplitude*tmpPhVec
                for a in range(coord.shape[0]):
                    axsf.write("\t{}\t{:.7f}\t{:.7f}\t{:.7f}\n".format(
                        newGeo.atoms[a].Z, *tmpCoord[a]
                    ))


def fat_phonon_bands(
    geom,
    name,
    first_band: int,
    last_band: int,
    path="./phonon",
    Erange=None,
    figsize=(8, 6),
    project_list: Union[List, Tuple, np.ndarray] = None,
    label: str = None,
    line_opacity=0.0,
    marker_size=50,
    cmap="inferno_r",
    ticks_font=12,
    label_font=12,
    title_font=14,
    border_line_width=2,
    save=False,
    save_format="png",
    dpi=600,
    ax2=True,
    **kwargs,
):
    """
    Plot the fat phonon dispersion relation projecting on selected atoms
    Arguments:
        first_band: first band to project
        last_band: last band to project
        path: path to load and write files
        Erange: energy range to plot the dispersion, in meV unit
        figsize: figure size
        project_list: list of atoms to be projected on
        label: label to be shown in the title of the figure
        line_opacity: opacity of the original dispersion lines
        marker_size: size of the markers of fat bands
        cmap: color map
        ticks_font, label_font, title_font, border_line_width: arguments for figure
        save: save figures or not
        save_format: format of the figuer to be saved, usually png, or pdf
        dpi: dots per inch
        ax2: plot vertical axis at right or no, in frequency units, while the default
            left axis is in energy meV unit
    """
    # read phonon band data from name.bands file in phonon calculation directory
    bands = read_phonon_bands(name=name, path=path,
                              as_dataarray=True, squeeze=True)
    # read all the phonon vectors
    ph_kpts, ph_enrgs, ph_vectors = read_phonon_vectors(
        geom=geom, name=name, path=path, first_band=first_band, last_band=last_band
    )
    # Convert k points to one dimension, as we are mainly dealing with one
    # dimensional system
    kpts = ph_kpts[:, 0]
    # modulus of phonon vectors of all atoms
    ph_mod_tot = np.linalg.norm(ph_vectors[:, :, :, :], axis=-1).sum(-1)
    # modulus of phonon vectors of selected to-be-projected atoms
    ph_mod_proj = np.linalg.norm(
        ph_vectors[:, :, project_list, :], axis=-1).sum(-1)
    ph_wt_proj = ph_mod_proj / ph_mod_tot

    fig = plt.figure(figsize=figsize)
    ax1 = fig.add_subplot(111)
    if Erange:
        emin, emax = Erange
        ax1.set_ylim(emin, emax)
    else:
        emin, emax = -1e2, 1e6
    ax1.set_ylabel("Energy (meV)", fontsize=label_font)
    ax1.set_xticks(bands.ticks)
    ax1.set_xticklabels(bands.ticklabels, fontsize=ticks_font)
    ax1.set_xlim(bands.ticks)
    if ax2:
        ax2 = ax1.twinx()
        ax2.set_ylabel("Frequency ($cm^{-1}$)", fontsize=label_font)
        ax2.set_ylim(np.array(ax1.get_ylim()) * 8.066)

    # plot the data
    for i in range(last_band - first_band + 1):
        band = ph_enrgs[:, i]
        if np.any(np.logical_and(band > emin, band < emax)):
            # plot original dispersion
            ax1.plot(kpts, band, color="k", alpha=line_opacity, **kwargs)
            # plot fat dispersion
            fat_disp = ax1.scatter(
                kpts, band, s=marker_size, c=ph_wt_proj[:, i], cmap=cmap
            )
    plt.colorbar(fat_disp, ax=ax1, shrink=0.8, location="right", pad=0.15)

    fat_disp.set_clim(0.0, 1.0)
    fig_title = "Fat Phonon Dispersion for {}".format(label)
    ax1.set_title(fig_title + "\n", fontsize=title_font)

    # set border width
    for border in ["left", "bottom", "top", "right"]:
        ax1.spines[border].set_linewidth(border_line_width)

    # save the figure
    if save:
        enrg_str = "{}to{}meV".format(emin, emax) if Erange else "full_range"
        fig_name = name + "_FatPhononDispersion-{}_".format(label)
        fig_name += enrg_str
        fig_path = os.path.join(path, fig_name + "." + save_format)
        fig.savefig(fig_path, dpi=dpi)


def write_xyz_trajectory(geo, path, filename, phvec, iev, energy, steps=100,
    unit_cells=3):
    """Doesn't work for Avogadro"""
    coord = geo.xyz
    with open(os.path.join(path, filename), 'w') as f:
        f.write(f"# ---- xyz trajectory ----\n")
        f.write("# iev = {}\t energy = {} meV (freq = {} cm-1)\n".format(
            iev, energy, energy*8.066))
        for i in range(steps):
            f.write(f'{geo.na}\n')
            f.write(f" {i+1}\n")
            tmpCoord = coord + phvec*np.sin(2*np.pi*i/steps)
            tmpCoord = np.abs(tmpCoord)
            for a in range(coord.shape[0]):
                f.write("\t{}\t{:.7f}\t{:.7f}\t{:.7f}\n".format(
                    geo.atoms[a].tag, *tmpCoord[a]
                ))
