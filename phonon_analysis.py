import os
import numpy as np
import matplotlib.pyplot as plt
from sisl.io import get_sile
from .geometry import *
from .tools import *
import xarray
from typing import List, Tuple, Union


def read_phonon_bands(
    name, path="./phonon", as_dataarray=True, squeeze=True
) -> xarray.DataArray:
    """
    Read phonon band structure from name.bands file, which is generated by
    Siesta/Util/Vibra
    """

    bands_path = os.path.join(path, f"{name}.bands")
    # read data using methods in sisl
    bandsile = get_sile(bands_path)
    bands = bandsile.read_data(as_dataarray=as_dataarray)
    # remove redundant dimension of data
    if squeeze:
        bands = bands.squeeze()
    try:
        if bands.ticklabels[0] == "Gamma":
            bands.ticklabels[0] = "$\Gamma$"
        if bands.ticklabels[1] == "X":
            bands.ticklabels[1] = "$X$"
        bands.k.data[:] *= 1.8897259886
        bands.ticks[:] = np.array(bands.ticks)*1.8897259886
    except:
        pass
    return bands

def read_phonon_vectors(
    name, path, first_band: int=1, last_band: int=None
):
    """
    Read the phonon eigenvectors from name.vectors file. By default read the
    vectors for all k points and selected bands.
    Return kpoints, energies, and vectors
    Arguments:
        first_band: first band to read
        last_band: last band to read
    """
    # empty list to store all the vectors
    vectors = []
    vec_path = os.path.join(path, f"{name}.vectors")
    # empty list to store all k points
    kpts = []
    # empty list to store all energy values (in meV)
    enrgs = []
    # indicator of number of empty lines. If more than 2 empty lines then it marks
    # the end of file
    emp = 0
    # number of atoms
    NA = 0
    with open(vec_path, 'r') as vf:
        line = vf.readline()
        while 'Eigenmode (real part)' not in line:
            line = vf.readline()
        line = vf.readline()
        while 'Eigenmode (imaginary part)' not in line:
            NA += 1
            line = vf.readline()
    if not last_band:
        last_band = 3*NA
    with open(vec_path, "r") as vf:
        # keep reading the file until the end
        while emp < 3:
            line = vf.readline()
            if len(line) == 0:
                emp += 1
            # If find 'k' in the line, then it is the start of a data block that
            # stores all the data for that k point
            if "k" in line:
                # initialize empty list to store the data for a k point
                vectors_k = []
                enrg_k = []
                emp = 0
                # read the k point
                kline = line.strip().split()[-3:]
                kpts.append([float(i) for i in kline])
                # skip the unwanted vectors
                for b in range(first_band - 1):
                    for l in range(2 + 2 * (NA + 1)):
                        vf.readline()
                # now read the bands that we want
                for b in np.arange(first_band, last_band + 1):
                    band = int(vf.readline()[-6:].strip())  # label of band
                    freq = float(vf.readline().strip().split()[-1])  # cm-1
                    enrg = freq / 8.066
                    enrg_k.append(enrg)
                    # initialize empty array to store vectors for a band
                    vector_b = np.empty((NA, 3), dtype=complex)
                    # start to the read part of the vector
                    vf.readline()  # Eigenmode (real part)
                    for i in range(NA):
                        v = vf.readline().strip().split()
                        real = np.array([float(a) for a in v], dtype=complex)
                        vector_b[i] = real
                    # start to read the imaginary part of the vector
                    vf.readline()  # Eigenmode (imaginary part)
                    for i in range(NA):
                        v = vf.readline().strip().split()
                        imag = 1j * np.array([float(a) for a in v])
                        vector_b[i, :] += imag
                    vectors_k.append(vector_b)
                enrgs.append(enrg_k)
                vectors.append(vectors_k)
    kpts = np.array(kpts)
    kpts[:] *= 1.8897259886  # convert to Ang^-1
    enrgs = np.array(enrgs)
    vectors = np.array(vectors)
    return kpts, enrgs, vectors




def plot_phonon_bands(
    name,
    path="./phonon",
    Erange=None,
    figsize=(8, 6),
    ticks_fontsize=14,
    label_fontsize=14,
    title=False,
    title_fontsize=14,
    border_line_width=1.5,
    linewidth=1,
    save=False,
    save_format="png,svg",
    save_path='.',
    save_name='tmp',
    dpi=300,
    ax2=True,
    index=False,
    **kwargs,
):
    """
    Plot phonon band structure from name.bands file
    Arguments:
        name: name of the geometry, which is also the name of files
        path: path to read and write files
        Erange: energy range to plot the dispersion
        figsize: figure size
        ticks_fontsize, label_fontsize, title_fontsize, border_line_width: arguments for figure
        save, save_format, dpi: arguments for saving figure
        ax2: plot right axis in frequency (cm^-1) unit or not
    """

    bands = read_phonon_bands(name=name, path=path,
                              as_dataarray=True, squeeze=True)
    # k points
    ks = bands.k.data

    fig = plt.figure(figsize=figsize)
    # ax1 is in energy (meV) scale
    ax1 = fig.add_subplot(111)
    # set y axis limit if Energy range is given
    if Erange:
        emin, emax = Erange
        ax1.set_ylim(emin, emax)
    else:
        emin, emax = -1e2, 1e6
    ax1.set_ylabel("Energy (meV)", fontsize=label_fontsize)
    ax1.set_xticks(bands.ticks)
    ax1.set_xticklabels(bands.ticklabels)
    ax1.set_xlim([min(bands.ticks), max(bands.ticks)])
    ax1.tick_params(axis='x', labelsize=ticks_fontsize)
    ax1.tick_params(axis='y', labelsize=ticks_fontsize)

    # optional ax2 is in frequency (cm^-1) scale
    if ax2:
        ax2 = ax1.twinx()
        ax2.set_ylabel("Frequency ($cm^{-1}$)", fontsize=label_fontsize)
        ax2.set_ylim(np.array(ax1.get_ylim()) * 8.066)

    # plot the data
    for i in range(bands.shape[1]):
        band = bands[:, i] / 8.066
        # select the bands that are in the given energy window
        if np.any(np.logical_and(band > emin, band < emax)):
            ax1.plot(ks, band, color="k", linewidth=linewidth, **kwargs)
            if index:
                ax1.annotate(i+1, [ks[-1], band[-1]])
    if title:
        fig_title = "{}_PhononDispersion".format(name)
        ax1.set_title(fig_title + "\n", fontsize=title_fontsize)

    # set border width
    for border in ["left", "bottom", "top", "right"]:
        ax1.spines[border].set_linewidth(border_line_width)

    # save the figure
    if save:
        enrg_str = "{}to{}meV".format(emin, emax) if Erange else "full_range"
        fig_name = save_name + ".PhononDispersion." + enrg_str
        for fmt in save_format.split(","):
            fig_path = os.path.join(save_path, fig_name + "." + fmt)
            fig.savefig(fig_path, dpi=dpi, transparent=True, bbox_inches="tight")
        
    plt.show()



def write_phonon_vector_xsf(
    geo, name, path, 
    Emin: float, 
    Emax: float, 
    q=[0, 0, 0]
):
    """
    Write xsf files to visualize phonon modes at Gamma point
    (It is more complicated to visualize the phonon mode at general k point, as
    it's has to be represented by a video to fully interprete the info in the data)
    Argument:
        Emin: Lower bound of energy window, in meV
        Emax: Upper bound of energy window, in meV
        path: path to read and write files
        num_of_cells: number of unit cells to write
    """
    masses = get_masses([a.symbol for a in geo.atoms])

    coord = geo.xyz
    # lattice vector
    cell = geo.cell
    # reciprocal lattice vector, Ang^-1
    rcell = geo.rcell
    # reduced lattice coordinates. The full coordiante is R + r, R is vector of
    # the unit cell, r is the vector within the unit cell
    R = np.floor(coord/cell.diagonal())*cell.diagonal()

    bands = read_phonon_bands(name, path)
    # read kpts, in order to get _q and i_q
    kpts, _ , _ = read_phonon_vectors(name=name, path=path, 
        first_band=1, last_band=1)
    # calculate the real wavevector from reduced wavevector
    qReal = np.multiply(rcell.diagonal(), np.array(q))
    # find the closest k (or called q) point to specified q point from the kpts list
    i_q = 0
    _q = kpts[i_q]  # the q that is closest to qReal
    for i, qtmp in enumerate(kpts):
        if np.linalg.norm(qReal-qtmp) < np.linalg.norm(qReal-_q):
            i_q = i
            _q = qtmp
    b_q = bands[i_q,:]
    sub_bands = np.where(np.logical_and(b_q>Emin*8.066, b_q<Emax*8.066))[0]
    first_band=sub_bands[0]+1
    last_band=sub_bands[-1]+1
    kpts, enrgs, vectors = read_phonon_vectors(name=name, path=path, 
        first_band=first_band, last_band=last_band)

    for i, ib in enumerate(sub_bands):
        energy = enrgs[i_q, i]
        phvec = vectors[i_q, i, :, :]
        phvec /= np.sqrt(masses[:, None])  # Unweight the vectors
        # vector times e^(ikR)
        _phase = np.exp(1j*R*_q)
        newPhVec = np.multiply(phvec, _phase)
        xsf_file = "{}_K{:.2f}_B{}_{:.2f}meV.xsf".format(
            name, q[0], ib+1, energy)

        with open(os.path.join(path, xsf_file), "w") as xsf:
            xsf.write("# ---- XSF block for ---- \n")
            xsf.write("# q = {:.6f}\t{:.6f}\t{:.6f}\t\n".format(*_q))
            xsf.write(f"# mode = {ib+1}\n")
            xsf.write("# frequency = {:.2f} cm-1\n".format(energy*8.066))
            xsf.write("# energy = {:.2f} meV\n".format(energy))
            xsf.write("CRYSTAL\n")
            # write primitive cell
            xsf.write("PRIMVEC\n")
            for i in range(3):
                xsf.write("  {:.8f}  {:.8f}  {:.8f}\n".format(
                    *geo.cell[i, :]))
            xsf.write("PRIMCOORD\n")
            xsf.write("\t{}\t1\n".format(geo.na))
            # write coordinates and displacement vectors for each atoms
            for i, a, _ in geo.iter_species():
                xsf.write(
                    "  {}  {:.8f}  {:.8f}  {:.8f}  {:.8f}  {:.8f}  {:.8f}\n".format(
                        a.tag, *geo.xyz[i, :], *np.real(newPhVec[i, :])
                    )
                )




def write_phonon_vector_axsf(
    geo, name, path, 
    Emin: float, 
    Emax: float,
    q=[0, 0, 0]
):
    """
    Write one single axsf file to visualize phonon modes at Gamma point
    Argument:
        Emin: Lower bound of energy window, in meV
        Emax: Upper bound of energy window, in meV
        path: path to read and write files
        num_of_cells: number of unit cells to write
    """
    masses = get_masses([a.symbol for a in geo.atoms])

    coord = geo.xyz
    # lattice vector
    cell = geo.cell
    # reciprocal lattice vector, Ang^-1
    rcell = geo.rcell
    # reduced lattice coordinates. The full coordiante is R + r, R is vector of
    # the unit cell, r is the vector within the unit cell
    R = np.floor(coord/cell.diagonal())*cell.diagonal()

    bands = read_phonon_bands(name, path)
    # read kpts, in order to get _q and i_q
    kpts, _ , _ = read_phonon_vectors(name=name, path=path, 
        first_band=1, last_band=1)
    # calculate the real wavevector from reduced wavevector
    qReal = np.multiply(rcell.diagonal(), np.array(q))
    # find the closest k (or called q) point to specified q point from the kpts list
    i_q = 0
    _q = kpts[i_q]  # the q that is closest to qReal
    for i, qtmp in enumerate(kpts):
        if np.linalg.norm(qReal-qtmp) < np.linalg.norm(qReal-_q):
            i_q = i
            _q = qtmp
    b_q = bands[i_q,:]
    sub_bands = np.where(np.logical_and(b_q>Emin*8.066, b_q<Emax*8.066))[0]
    first_band=sub_bands[0]+1
    last_band=sub_bands[-1]+1
    kpts, enrgs, vectors = read_phonon_vectors(name=name, path=path, 
        first_band=first_band, last_band=last_band)

    xsf_file = "{}_K{:.2f}_B{}to{}.axsf".format(
        name, q[0], first_band, last_band)

    with open(os.path.join(path, xsf_file), "w") as xsf:
        xsf.write("# ---- AXSF block from band {} to {} ---- \n".format(
            first_band, last_band))
        xsf.write("# q = {:.6f}\t{:.6f}\t{:.6f}\t\n".format(*_q))
        xsf.write("ANIMSTEPS   {}\n".format(len(sub_bands)))
        xsf.write("CRYSTAL\n")
        # write primitive cell
        xsf.write("PRIMVEC\n")
        for i in range(3):
            xsf.write("  {:.8f}  {:.8f}  {:.8f}\n".format(
                *geo.cell[i, :]))

        for i, ib in enumerate(sub_bands):
            phvec = vectors[i_q, i, :, :]
            phvec /= np.sqrt(masses[:, None])  # Unweight the vectors
            # vector times e^(ikR)
            _phase = np.exp(1j*R*_q)
            newPhVec = np.multiply(phvec, _phase)

            xsf.write(f"PRIMCOORD   {i+1}\n")
            xsf.write("  {}  1\n".format(geo.na))
            # write coordinates and displacement vectors for each atoms
            for i, a, _ in geo.iter_species():
                xsf.write(
                    "  {}\t{:.8f}\t{:.8f}\t{:.8f}\t{:.8f}\t{:.8f}\t{:.8f}\n".format(
                        a.Z, *geo.xyz[i, :], *np.real(newPhVec[i, :])
                    )
                )



def write_phonon_movie(geo, name, path,
                     Emin, Emax, steps=100,
                     q=[0, 0, 0], amplitude=1.0):
    """
    Write AXSF file to visualize the phonon mode.
    Write files for multiple bands but for one specified wavevector (q)
    Args:
        geo: sisl Geometry
        path: path to read and write files
        steps: number of animation steps
        num_of_cells: number of unit cells to plot
    """
    masses = get_masses([a.symbol for a in geo.atoms])
    
    coord = geo.xyz
    # lattice vector
    cell = geo.cell
    # reciprocal lattice vector, Ang^-1
    rcell = geo.rcell
    # reduced lattice coordinates. The full coordiante is R + r, R is vector of
    # the unit cell, r is the vector within the unit cell
    R = np.floor(coord/cell.diagonal())*cell.diagonal()

    bands = read_phonon_bands(name, path)
    # read kpts, in order to get _q and i_q
    kpts, _ , _ = read_phonon_vectors(name=name, path=path, 
        first_band=1, last_band=1)
    # calculate the real wavevector from reduced wavevector
    qReal = np.multiply(rcell.diagonal(), np.array(q))
    # find the closest k (or called q) point to specified q point from the kpts list
    i_q = 0
    _q = kpts[i_q]  # the q that is closest to qReal
    for i, qtmp in enumerate(kpts):
        if np.linalg.norm(qReal-qtmp) < np.linalg.norm(qReal-_q):
            i_q = i
            _q = qtmp
    b_q = bands[i_q,:]
    sub_bands = np.where(np.logical_and(b_q>Emin*8.066, b_q<Emax*8.066))[0]
    first_band=sub_bands[0]+1
    last_band=sub_bands[-1]+1
    kpts, enrgs, vectors = read_phonon_vectors(name=name, path=path, 
        first_band=first_band, last_band=last_band)

    for i in range(last_band-first_band+1):
        ib = first_band+i-1
        energy = enrgs[i_q, i]
        axsf_file = "{}_K{:.2f}_B{}_{:.2f}meV.axsf".format(
            name, q[0], ib+1, energy)
        phvec = vectors[i_q, i, :, :]
        phvec /= np.sqrt(masses[:, None])  # Unweight the vectors
        # vector times e^(ikR)
        _phase = np.exp(1j*R*_q)
        newPhVec = np.multiply(phvec, _phase)
        with open(os.path.join(path, axsf_file), 'w') as axsf:
            axsf.write("# ---- AXSF block for ---- \n")
            axsf.write("# q = {:.6f}\t{:.6f}\t{:.6f}\t\n".format(*_q))
            axsf.write(f"# mode = {ib+1}\n")
            axsf.write("# frequency = {:.2f} cm-1\n".format(energy*8.066))
            axsf.write("# energy = {:.2f} meV\n".format(energy))
            axsf.write(f"ANIMSTEPS {steps}\n")
            axsf.write('CRYSTAL\n')
            axsf.write('PRIMVEC\n')
            for i in range(3):
                axsf.write('\t{:.9f}\t{:.9f}\t{:.9f}\n'.format(*cell[i]))
            for i in range(steps):
                axsf.write(f"PRIMCOORD {i+1}\n")
                axsf.write(f'\t{geo.na}\t1\n')
                tmpPhVec = newPhVec*np.exp(1j*(2*np.pi*i/steps+np.pi/2))
                tmpPhVec = np.real(tmpPhVec)
                tmpCoord = coord + amplitude*tmpPhVec
                for a in range(coord.shape[0]):
                    axsf.write("\t{}\t{:.7f}\t{:.7f}\t{:.7f}\n".format(
                        geo.atoms[a].tag, *tmpCoord[a]
                    ))




def fat_phonon_bands(
    geom,
    name,
    first_band: int,
    last_band: int,
    path="./phonon",
    Erange=None,
    figsize=(8, 6),
    project_list: Union[List, Tuple, np.ndarray] = None,
    label: str = None,
    line_opacity=0.0,
    marker_size=50,
    cmap="inferno_r",
    ticks_fontsize=12,
    label_fontsize=12,
    title_fontsize=14,
    border_line_width=2,
    save=False,
    save_format="png",
    dpi=600,
    ax2=True,
    **kwargs,
):
    """
    Plot the fat phonon dispersion relation projecting on selected atoms
    Arguments:
        first_band: first band to project
        last_band: last band to project
        path: path to load and write files
        Erange: energy range to plot the dispersion, in meV unit
        figsize: figure size
        project_list: list of atoms to be projected on
        label: label to be shown in the title of the figure
        line_opacity: opacity of the original dispersion lines
        marker_size: size of the markers of fat bands
        cmap: color map
        ticks_fontsize, label_fontsize, title_fontsize, border_line_width: arguments for figure
        save: save figures or not
        save_format: format of the figuer to be saved, usually png, or pdf
        dpi: dots per inch
        ax2: plot vertical axis at right or no, in frequency units, while the default
            left axis is in energy meV unit
    """
    # read phonon band data from name.bands file in phonon calculation directory
    bands = read_phonon_bands(name=name, path=path,
                              as_dataarray=True, squeeze=True)
    # read all the phonon vectors
    ph_kpts, ph_enrgs, ph_vectors = read_phonon_vectors(
        name=name, path=path, first_band=first_band, last_band=last_band
    )
    # Convert k points to one dimension, as we are mainly dealing with one
    # dimensional system
    kpts = ph_kpts[:, 0]
    # modulus of phonon vectors of all atoms
    ph_mod_tot = np.linalg.norm(ph_vectors[:, :, :, :], axis=-1).sum(-1)
    # modulus of phonon vectors of selected to-be-projected atoms
    ph_mod_proj = np.linalg.norm(
        ph_vectors[:, :, project_list, :], axis=-1).sum(-1)
    ph_wt_proj = ph_mod_proj / ph_mod_tot

    fig = plt.figure(figsize=figsize)
    ax1 = fig.add_subplot(111)
    if Erange:
        emin, emax = Erange
        ax1.set_ylim(emin, emax)
    else:
        emin, emax = -1e2, 1e6
    ax1.set_ylabel("Energy (meV)", fontsize=label_fontsize)
    ax1.set_xticks(bands.ticks)
    ax1.set_xticklabels(bands.ticklabels, fontsize=ticks_fontsize)
    ax1.set_xlim(bands.ticks)
    if ax2:
        ax2 = ax1.twinx()
        ax2.set_ylabel("Frequency ($cm^{-1}$)", fontsize=label_fontsize)
        ax2.set_ylim(np.array(ax1.get_ylim()) * 8.066)

    # plot the data
    for i in range(last_band - first_band + 1):
        band = ph_enrgs[:, i]
        if np.any(np.logical_and(band > emin, band < emax)):
            # plot original dispersion
            ax1.plot(kpts, band, color="k", alpha=line_opacity, **kwargs)
            # plot fat dispersion
            fat_disp = ax1.scatter(
                kpts, band, s=marker_size, c=ph_wt_proj[:, i], cmap=cmap
            )
    plt.colorbar(fat_disp, ax=ax1, shrink=0.8, location="right", pad=0.15)

    fat_disp.set_clim(0.0, 1.0)
    fig_title = "Fat Phonon Dispersion for {}".format(label)
    ax1.set_title(fig_title + "\n", fontsize=title_fontsize)

    # set border width
    for border in ["left", "bottom", "top", "right"]:
        ax1.spines[border].set_linewidth(border_line_width)

    # save the figure
    if save:
        enrg_str = "{}to{}meV".format(emin, emax) if Erange else "full_range"
        fig_name = name + "_FatPhononDispersion-{}_".format(label)
        fig_name += enrg_str
        fig_path = os.path.join(path, fig_name + "." + save_format)
        fig.savefig(fig_path, dpi=dpi)


def write_xyz_trajectory(geo, path, filename, phvec, iev, energy, steps=100,
    unit_cells=3):
    """Doesn't work for Avogadro"""
    coord = geo.xyz
    with open(os.path.join(path, filename), 'w') as f:
        f.write(f"# ---- xyz trajectory ----\n")
        f.write("# iev = {}\t energy = {} meV (freq = {} cm-1)\n".format(
            iev, energy, energy*8.066))
        for i in range(steps):
            f.write(f'{geo.na}\n')
            f.write(f" {i+1}\n")
            tmpCoord = coord + phvec*np.sin(2*np.pi*i/steps)
            tmpCoord = np.abs(tmpCoord)
            for a in range(coord.shape[0]):
                f.write("\t{}\t{:.7f}\t{:.7f}\t{:.7f}\n".format(
                    geo.atoms[a].tag, *tmpCoord[a]
                ))


def view_phonon(xsfFile,
    width=500,
    height=500,
    frames=10,
    amplitude=1,
):
    with open(xsfFile,'r') as xsf:
        #phData = xsf.read().split('\n')
        #phData = ''.join(phData[phData.index('PRIMCOORD')+2:])
        phData = re.findall('[A-Z][a-z]?(?:  -?[0-9]+\.[0-9]+){6}', xsf.read())
        # print(str(len(phData)))
        N = len(phData)
        phData = '\n'.join(phData)
        phData = str(N)+'\n \n'+phData
    xyzview = py3Dmol.view(width=width, height=height)
    xyzview.addModel(phData, 'xyz',{'vibrate': 
        {'frames':frames,'amplitude':amplitude}})
    xyzview.setStyle({'sphere': {'colorscheme': 'Jmol', 'scale': 0.3},
                        'stick': {'colorscheme': 'Jmol', 'radius': 0.2}})
    xyzview.animate({'loop': 'backAndForth'})
    xyzview.zoomTo()
    xyzview.show()